// Generated by Reflector from C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
// CJS: Hand-edited after decompiling

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Threading;

//warning CS0420: `Flow.ConcurrentQueue<T>.Segment<T>.m_high': A volatile field references will not be treated as volatile
// see http://stackoverflow.com/questions/425132/a-reference-to-a-volatile-field-will-not-be-treated-as-volatile-implications
#pragma warning disable 420

//warning CS0618: `System.Security.Permissions.SecurityAction' is obsolete: `CAS support is not available with Silverlight applications.' 
#pragma warning disable 618

namespace Flow
{
	// CJS See http://stackoverflow.com/questions/12550749/what-is-the-dynamicallyinvokable-attribute-for
	internal class __DynamicallyInvokable : Attribute
	{
	}

	[Serializable, ComVisible(false), DebuggerDisplay("Count = {Count}"), __DynamicallyInvokable,
	 HostProtection(SecurityAction.LinkDemand, Synchronization = true, ExternalThreading = true)]
	//CJS public class ConcurrentQueue<T> : IProducerConsumerCollection<T>, IEnumerable<T>, ICollection, IEnumerable
	public class ConcurrentQueue<T> : IEnumerable<T>, ICollection, IEnumerable
	{
		private const int SEGMENT_SIZE = 0x20;

		[NonSerialized] private volatile Segment<T> m_head;

		[NonSerialized] internal volatile int m_numSnapshotTakers;

		private T[] m_serializationArray;

		[NonSerialized] private volatile Segment<T> m_tail;

		[__DynamicallyInvokable]
		public ConcurrentQueue()
		{
			m_head = m_tail = new Segment<T>(0L, this);
		}

		[__DynamicallyInvokable]
		public ConcurrentQueue(IEnumerable<T> collection)
		{
			if (collection == null)
				throw new ArgumentNullException("collection");
			InitializeFromCollection(collection);
		}

		[__DynamicallyInvokable]
		public bool IsEmpty
		{
			[__DynamicallyInvokable]
			get
			{
				Segment<T> head = m_head;
				if (head.IsEmpty)
				{
					if (head.Next == null)
						return true;
					var wait = new SpinWait();
					while (head.IsEmpty)
					{
						if (head.Next == null)
							return true;
						wait.SpinOnce();
						head = m_head;
					}
				}
				return false;
			}
		}

		[__DynamicallyInvokable]
		void ICollection.CopyTo(Array array, int index)
		{
			if (array == null)
				throw new ArgumentNullException("array");

			//CJS this.ToList().CopyTo(array, index);
			throw new NotImplementedException();
		}

		[__DynamicallyInvokable]
		public int Count
		{
			[__DynamicallyInvokable]
			get
			{
				Segment<T> segment;
				Segment<T> segment2;
				int num;
				int num2;
				GetHeadTailPositions(out segment, out segment2, out num, out num2);
				if (segment == segment2)
					return ((num2 - num) + 1);
				int num3 = 0x20 - num;
				num3 += 0x20*((int) ((segment2.m_index - segment.m_index) - 1L));
				return (num3 + (num2 + 1));
			}
		}

		[__DynamicallyInvokable]
		bool ICollection.IsSynchronized
		{
			[__DynamicallyInvokable] get { return false; }
		}

		[__DynamicallyInvokable]
		object ICollection.SyncRoot
		{
			[__DynamicallyInvokable] get { throw new NotSupportedException("ConcurrentCollection_SyncRoot_NotSupported"); }
		}

		[__DynamicallyInvokable]
		public IEnumerator<T> GetEnumerator()
		{
			Segment<T> segment;
			Segment<T> segment2;
			int num;
			int num2;
			Interlocked.Increment(ref m_numSnapshotTakers);
			GetHeadTailPositions(out segment, out segment2, out num, out num2);
			return GetEnumerator(segment, segment2, num, num2);
		}

		[__DynamicallyInvokable]
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		[__DynamicallyInvokable]
		public void CopyTo(T[] array, int index)
		{
			if (array == null)
				throw new ArgumentNullException("array");
			ToList().CopyTo(array, index);
		}

		[__DynamicallyInvokable]
		public void Enqueue(T item)
		{
			var wait = new SpinWait();
			while (!m_tail.TryAppend(item))
			{
				wait.SpinOnce();
			}
		}

		private IEnumerator<T> GetEnumerator(Segment<T> head, Segment<T> tail, int headLow, int tailHigh)
		{
			var iteratorVariable0 = new SpinWait();
			if (head == tail)
			{
				for (int i = headLow; i <= tailHigh; i++)
				{
					iteratorVariable0.Reset();
					while (!head.m_state[i].m_value)
					{
						iteratorVariable0.SpinOnce();
					}
					yield return head.m_array[i];
				}
			}
			else
			{
				for (int j = headLow; j < 0x20; j++)
				{
					iteratorVariable0.Reset();
					while (!head.m_state[j].m_value)
					{
						iteratorVariable0.SpinOnce();
					}
					yield return head.m_array[j];
				}
				for (Segment<T> iteratorVariable3 = head.Next;
					iteratorVariable3 != tail;
					iteratorVariable3 = iteratorVariable3.Next)
				{
					for (int m = 0; m < 0x20; m++)
					{
						iteratorVariable0.Reset();
						while (!iteratorVariable3.m_state[m].m_value)
						{
							iteratorVariable0.SpinOnce();
						}
						yield return iteratorVariable3.m_array[m];
					}
				}
				for (int k = 0; k <= tailHigh; k++)
				{
					iteratorVariable0.Reset();
					while (!tail.m_state[k].m_value)
					{
						iteratorVariable0.SpinOnce();
					}
					yield return tail.m_array[k];
				}
			}
		}

		private void GetHeadTailPositions(out Segment<T> head, out Segment<T> tail, out int headLow, out int tailHigh)
		{
			head = m_head;
			tail = m_tail;
			headLow = head.Low;
			tailHigh = tail.High;
			var wait = new SpinWait();
			while ((((head != m_head) || (tail != m_tail)) || ((headLow != head.Low) || (tailHigh != tail.High))) ||
			       (head.m_index > tail.m_index))
			{
				wait.SpinOnce();
				head = m_head;
				tail = m_tail;
				headLow = head.Low;
				tailHigh = tail.High;
			}
		}

		private void InitializeFromCollection(IEnumerable<T> collection)
		{
			var segment = new Segment<T>(0L, this);
			m_head = segment;
			int num = 0;
			foreach (T local in collection)
			{
				segment.UnsafeAdd(local);
				num++;
				if (num >= 0x20)
				{
					segment = segment.UnsafeGrow();
					num = 0;
				}
			}
			m_tail = segment;
		}

		[OnDeserialized]
		private void OnDeserialized(StreamingContext context)
		{
			InitializeFromCollection(m_serializationArray);
			m_serializationArray = null;
		}

		[OnSerializing]
		private void OnSerializing(StreamingContext context)
		{
			m_serializationArray = ToArray();
		}

		[__DynamicallyInvokable]
		//CJS bool IProducerConsumerCollection<T>.TryAdd(T item)
		public bool TryAdd(T item)
		{
			Enqueue(item);
			return true;
		}

		//CJS [__DynamicallyInvokable, TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]
		//CJS bool IProducerConsumerCollection<T>.TryTake(out T item)
		public bool TryTake(out T item)
		{
			return TryDequeue(out item);
		}

		[__DynamicallyInvokable]
		public T[] ToArray()
		{
			return ToList().ToArray();
		}

		private List<T> ToList()
		{
			Interlocked.Increment(ref m_numSnapshotTakers);
			var list = new List<T>();
			try
			{
				Segment<T> segment;
				Segment<T> segment2;
				int num;
				int num2;
				GetHeadTailPositions(out segment, out segment2, out num, out num2);
				if (segment == segment2)
				{
					segment.AddToList(list, num, num2);
					return list;
				}
				segment.AddToList(list, num, 0x1f);
				for (Segment<T> segment3 = segment.Next; segment3 != segment2; segment3 = segment3.Next)
				{
					segment3.AddToList(list, 0, 0x1f);
				}
				segment2.AddToList(list, 0, num2);
			}
			finally
			{
				Interlocked.Decrement(ref m_numSnapshotTakers);
			}
			return list;
		}

		[__DynamicallyInvokable]
		public bool TryDequeue(out T result)
		{
			while (!IsEmpty)
			{
				if (m_head.TryRemove(out result))
					return true;
			}
			result = default(T);
			return false;
		}

		[__DynamicallyInvokable]
		public bool TryPeek(out T result)
		{
			while (!IsEmpty)
			{
				if (m_head.TryPeek(out result))
					return true;
			}
			result = default(T);
			return false;
		}

		internal class Segment<T2>
		{
			internal readonly long m_index;

			internal volatile T2[] m_array;

			private volatile int m_high;

			private volatile int m_low;

			private volatile ConcurrentQueue<T2>.Segment<T2> m_next;

			private volatile ConcurrentQueue<T2> m_source;

			internal volatile VolatileBool[] m_state;

			internal Segment(long index, ConcurrentQueue<T2> source)
			{
				m_array = new T2[0x20];
				m_state = new VolatileBool[0x20];
				m_high = -1;
				m_index = index;
				m_source = source;
			}

			internal int High
			{
				get { return Math.Min(m_high, 0x1f); }
			}

			internal bool IsEmpty
			{
				get { return (Low > High); }
			}

			internal int Low
			{
				get { return Math.Min(m_low, 0x20); }
			}

			internal ConcurrentQueue<T2>.Segment<T2> Next
			{
				get { return m_next; }
			}

			internal void AddToList(List<T2> list, int start, int end)
			{
				for (int i = start; i <= end; i++)
				{
					var wait = new SpinWait();
					while (!m_state[i].m_value)
					{
						wait.SpinOnce();
					}
					list.Add(m_array[i]);
				}
			}

			internal void Grow()
			{
				var segment = new ConcurrentQueue<T2>.Segment<T2>(m_index + 1L, m_source);
				m_next = segment;
				m_source.m_tail = m_next;
			}

			internal bool TryAppend(T2 value)
			{
				if (m_high >= 0x1f)
					return false;
				int index = 0x20;
				try
				{
				}
				finally
				{
					index = Interlocked.Increment(ref m_high);
					if (index <= 0x1f)
					{
						m_array[index] = value;
						m_state[index].m_value = true;
					}
					if (index == 0x1f)
						Grow();
				}
				return (index <= 0x1f);
			}

			internal bool TryPeek(out T2 result)
			{
				result = default(T2);
				int low = Low;
				if (low > High)
					return false;
				var wait = new SpinWait();
				while (!m_state[low].m_value)
				{
					wait.SpinOnce();
				}
				result = m_array[low];
				return true;
			}

			internal bool TryRemove(out T2 result)
			{
				var wait = new SpinWait();
				int low = Low;
				for (int i = High; low <= i; i = High)
				{
					if (Interlocked.CompareExchange(ref m_low, low + 1, low) == low)
					{
						var wait2 = new SpinWait();
						while (!m_state[low].m_value)
						{
							wait2.SpinOnce();
						}
						result = m_array[low];
						if (m_source.m_numSnapshotTakers <= 0)
							m_array[low] = default(T2);
						if ((low + 1) >= 0x20)
						{
							wait2 = new SpinWait();
							while (m_next == null)
							{
								wait2.SpinOnce();
							}
							m_source.m_head = m_next;
						}
						return true;
					}
					wait.SpinOnce();
					low = Low;
				}
				result = default(T2);
				return false;
			}

			internal void UnsafeAdd(T2 value)
			{
				m_high++;
				m_array[m_high] = value;
				m_state[m_high].m_value = true;
			}

			// CJS: was internal
			internal ConcurrentQueue<T2>.Segment<T2> UnsafeGrow()
			{
				var segment = new ConcurrentQueue<T2>.Segment<T2>(m_index + 1L, m_source);
				m_next = segment;
				return segment;
			}
		}
	}
}
